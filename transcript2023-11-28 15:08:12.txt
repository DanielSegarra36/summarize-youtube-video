hi everyone in this lecture we're going to take a look at network programming and we're actually going to divide this subject into two lectures this is going to be part one of two so in this lecture this week we're going to take a look at how we can create a server application that listens out for client applications attempting to connect to it and then in the next lecture in part two we'll take a look at how the server and client applications can send data back and forth from each other using udp and tcp connections okay so here in part one in this lecture we'll take a look at the code that we need to use to set up a socket so that the server can listen out for a client attempting to connect to it so let's start by having a look at the socket and sockets were initially developed for unix systems it was only later that windows developed their own version of the sockets called winsock which is short for windows socket and windsock is another example of an api that works with low-level windows types a bit like our threading examples from a previous lecture to be able to make use and interact with the resources of the operating system by the way wsa is short for windows sockets api so whenever you see wsa in the code that's what it's referring to on windows systems the core components of the socket come in the form of a dll file which specifically is the ws2 underscore 32 file which is located in the system 32 folder of the core installation of windows and if you're unfamiliar that dll files are specific to windows stands for dynamic link library and these are files that contain compiled code that can be reused by multiple applications so rather than having to duplicate this code which of course the socket will handle the connection between the hardware and the software so it'll take care of all the low-level ports and ip addresses and the connections between the two layers rather than having to repeat that and duplicate that in every application that wants to make use of the socket functionality it's written once and placed within a dll file so that all the applications that want to make use of that functionality just have to incorporate that dll file which we're going to take a look at how we can do that in our visual studio projects we're going to walk through the process of including that file so we can then code our applications to work with that dll code base rather than having to manage that process ourselves let's now move on and have a look at the osi model which i'm sure if you've taken a networking module before i'm sure this will be familiar to you you've probably seen this diagram but for those who haven't or even those that have and haven't seen it for some time i thought it'd be useful to visualize how we send data from one application to another application across a network so really up until now we've only been concerned with one machine and at the highest level of that machine the application layer of writing things that appear on the software and well maybe with the exception of threading when we ventured down a little bit lower to make use of uh some system resources perhaps that comes down to the session layer making use of their apis and aspects of the operating system but we've only really been concerned with the top layers of this osi model but in order to use a network and get things from one machine to another we have to descend even lower and get to the physical layers and the network layers of this model and this model osi by the way stands for open systems interconnection and it conceptualizes seven layers between the high level software layer the application layer down to the physical layer the hardware essentially so starting at the top layer the application this is where we're going to write our c-plus plus code and create a exe that runs on our machines and then in order to get data to another application we have to break this data down into packets and there's processes for that in the presentation layer that's to do with serialization doing things in order and buffering if there's uh bandwidth considerations and we we kind of packet everything up we kind of break this data down into smaller bits and pieces and then send it via a socket so this comes into the session layer the layer below presentation and we're going to be exploring sockets in more detail over the course of this lecture but then the layer lower than that is the transport layer and this is to do with how we will transport our packets so we're going to explore the tcp and udp protocols and we're going to explore this in the next lecture the differences between these two protocols um so we'll come on to that then but this is just two different approaches for how we might transport the packets and the bytes from one machine to another then taking it a step lower we get to the network layer which is concerned with the ip address of the machine internet protocol so each machine has an ip address on a network and that's going to be useful for identifying each machine on the network and then taking that level lower we come to the actual data link the sort of networking card if you like that has an ethernet port and that in itself has its own mac address so it can be identified in case there are multiple network cards on the machine and then we get to the physical layer the actual electronics and the the hardware and the the connections between machine and router on the left hand side we descended from application layer top level c plus plus code down to the physical layer that then goes into root it and notice that that just has three layers it doesn't have the high level layers associated with the software and the operating system but it goes up and goes down those three layers to then come out the other side and go to another machine and then ascend through the same layers doing all the layers we outlined to send the data from application down to physical then it then ascends those layers to get back to the application at the other end the machine that's uh to receive this data okay so this is what happens underneath the surface when we want to send data from one machine to another over a network so now that we've seen the osi model we now know that in order for a connection to take place between two devices or more specifically for one device to send data to another device via a network we now know that the data has to be sent from the application layer and then descend down to the physical layer of the sending device and then to ascend from the physical layer to the application layer in order for it to be received at the other device so whilst the osi layers will be the same for the two devices connected via the network the roles and the tasks that these two devices perform will differ in a client server architecture now that's where we will label one of the devices to be a client and the other device to be a server and they each perform different roles and tasks now it's true that a server can have connections with more than one client and also a client can have connections with more than one server but the roles of the server are to listen out on a port number and a certain ip address for clients which could be more than one client attempting to send a request to connect to the server via that port number okay so whilst the client and the server will share similar networking code in order to facilitate a connection between each other the server has the responsibilities of listening out for connections for clients and the client can send requests to connect to a certain ip and port number and devices on the network are given their own unique ip address so therefore if the server and client are connected on the same local network then the network setup will allocate them at usually a static ip address uh which will reflect the fact that they are in the same network but they will also be unique as well uh for each machine so that each machine can be identified by its unique ip address and machines on a network that are intending to maintain a constant connection with the server tend to be allocated a static ip address meaning that they won't change because there's no need for it to change if it's always going to be connected with the server however examples of dynamic ip allocation may be for wireless devices for example which may well join for a period of time and then exit the network so that's in the case of a lan a local area network where there are multiple machines connected to a router but in our case for the practicals we're going to simplify things just to get started where we are going to use the same machine and create one application for the server and then on the same machine have another application enacting the client so that they don't have to connect via a network they can instead go down the layers of the osi model on the same device and of course back up again so we're going to use the loopback address which is 127.0.0.1 which refers to the current machine and you should find this is a reserved address reserved for the particular machine and this will facilitate the connection simulating the network of course because it will still descend and ascend the osi layers um but useful just for testing it out on our machine first and saves us having to set up a network to connect different devices together but of course if you want to extend the practicals uh for this week this is something that you might want to try doing so if you have access to a router at home and have different devices you could well try and configure the network so that you could run the server application on one machine and then get it to chat to the client application on a different machine via the network but just remember that each device on the network has its own unique ip address so remember that you'll have to configure the applications for that they won't be the same ip address in the practicals that we're going to do because we're working with one machine all right so just remember that if you're going to give it a go but i suggest we have a go first at setting up the client and server to run on the same machine before start branching out and trying it across the network because of course there's a lot of network code to have a look at so just before we move on though we're about to look at ports in a little bit more detail and there's a point here that's worth raising in that when developing the network programs remember that the port number of the server is usually specified within the code but this differs to the client port number which is allocated by the os all right and we'll see later that the client whilst it's allocated the port can specify the port number that it wants to connect to so it's going to be allocated a port for the socket which it can't change but it can specify that it wants to connect to the port number of the server which is specified in the code all right so let's move on and talk a little bit more about ports now and so for every machine which has an ip address on the network there will be even more ports available on that machine for which the machine can send and receive data so this maps onto the real world where each country has a number of ports upon the coastline for which cargo and goods can be delivered into the country and also sent out from the country and so if i wanted to send something from the uk to france let's say well i'd have to arrange a port on the uk coastline for it to go out from and then be received at a port in france that could be calais in france and let's say i want to send from dover then i've selected a port to be sent from the sending address let's say that's uk and then a port on the receiving address france to be received at in order to get my item from the uk to france all right so that's the analogy that we could use for networking let's say we had two machines and they have their own address their own ip address which is the equivalent of the postal address let's say uk and france all right and i have to select a port at each one of those addresses for the data to be sent from and then received by at the receiving address okay so we have a sending address and sending port number and then we have a receiving port number so that it can get to the receiving address and in terms of our machines on a network we have a wide selection of port numbers that we can choose from in order to send and receive data and to have a range of up to 65 000 ports okay so lots to choose from which translates to a 16-bit address but bear in mind that the first thousand ports or 1024 ports are reserved for well-known applications and an example here is that port 21 is file transfer protocol that's uh ftp there okay so it's recommended that choose a port number greater than 1024 and i think in our practical we're going to go with the port number 55 5555. that tends to be a constantly available port number it's not in demand so that tends to work all right so we'll have a go at setting that up later great so now that we've established that each machine on a network has its own unique ip address and then at each ip address there will be a different number of ports in which data can be sent from and then received by okay now that we've covered that information what we can do is we can actually undergo a process of binding that ip address and port number to a dedicated socket now there'll be one for the server which listens out for clients attempting to connect to that socket and then the client itself will create a socket which will specify the details of the server the ip address and the port number that it wants to connect to so we have this two-way reciprocal connection here the server is in listening mode willing to accept requests that come in and then the client is active in sending out requests to those particular details the ip address and the port number and then once this connection has been established once the request from the client is approved by the server the socket will then facilitate two-way connection where data can be sent and received via that socket all right so essentially the socket acts as the pipe between two computers on a network to enable data to be transferred between the nodes on a network and so there are two different types of sockets which we're going to explore further on in part two in the next lecture but just to give you a summary there is the streaming socket which utilizes the tcp protocol stands for transmission control protocol and this tends to be a more secure connection between server and clients and it's constantly checking that this connection is established to send data and it sends it in the form of packets as all computers do and then reassembles it at the receiving location but this is in contrast to udp which is user datagram protocol which doesn't require connection to be established it doesn't even check to see whether the receiving end is set up and live to receive this information that's being sent so for cases where information is going to be broadcast every second then if one of those seconds goes missing or isn't received then that's not a major deal because there's going to be further updates coming down the line all right so udp is uh less reliable and less secure because it doesn't require a connection but uh is faster and does have its uses but we'll unpack this and discuss this more in the next lecture so for now let's uh transition and have a look at an illustration now of how to create a socket for the server and then how to create a socket for the client and how the to establish a connection together let's take a look at an illustration now which will hopefully visualize the process of a client attempting to connect to a server so you'll see here on the right hand side the first step we've got the server depicted as a rectangle and within the server we're going to create a socket which is depicted as an oval here and you'll notice that this socket doesn't currently have an ip address or a port number attached to it hence the status of this socket is unbound but when we bind this socket what we're doing is we actually bind the ip address and the port number to the socket itself so you notice now that the status has changed from unbound to bound and that we see the appropriate details for the ip address and the port number that we are going to set up the socket to listen out on and that's the next step so if we go to the next line now you'll see that we've changed from the status of being bound to listening so what we're doing here was now that we've bound the socket bound the details of the ip address and the port number as the socket we are now in listening mode where we are listing out for incoming requests on those details so through that port number we're listening out for clients to connect to this socket through that port number and uh now let's say that a client comes along and it wants to connect to the server well first it's going to have to create a socket of its own so whether this is another machine on the same local network as the server or indeed the same machine in our case for for our practicals we're going to keep it nice and easy and we're going to create the server and the client on the same machine and get them to talk to each other via different visual studio projects and separate compiled applications running at the same time but regardless of whether it's the same machine or two different computers on the same network the client is still going to have to create its own sockets which as the server did it starts as unbound and then when the details are added when it is bound you'll notice here that the ip address for the client is the same in this case this is going to resemble our practical so the ip address will be the same because it's the same computer but the port number will be different and the client doesn't actually have any control over the port number this is allocated automatically for the server this can be specified the port number that it wants to listen out on but regardless what it can do is put out a request once it's been bound so it can put out a request to connect to the port number of the server so even though it exists on its own different port number it can put out a request to connect to the port number of the server and then once that request has been acknowledged and accepted by the server notice here that we don't just connect the two sockets but the server actually duplicates itself actually duplicates the socket to enable the connection between the server and the client notice there the arrow pointing between the duplicated the newly created socket which has status connected there and holds the same port number and ip address as the server but then we also maintain the original socket which is still listening out on that port for any other clients that may want to connect to that port number so the server can simultaneously maintain its connection with clients it just creates a new socket for them as well as listing out for other clients attempting to connect to that socket so now that we've had a look at the illustration of how the client connects to the server and how the socket is created we're now going to transition and have a look at how we can code such a process and for the server this maps out to be seven individual steps and in this presentation we're going to cover the first five from initializing the socket to creating the sockets and then thirdly binding the socket to the port number and ip and then listening out for clients connecting to that socket and then accepting and connecting a client once it connects so we're going to cover the first five steps and have a look at the code block for each one of those steps in this presentation and then in part two in the next presentation will cover sending and receiving data in both the tcp and udp protocols all right so seven steps for the server but if you move on to the client we've actually got five steps here and you notice that the first two are the same in terms of initializing the socket and creating the sockets but then rather than binding the socket the client just attempts to connect to the given ip and port number so the third step is different technically to the third step of the server but the connection will still be the same i think that maps on to the fifth step of the server there so we're just skipping out basically step three and four of the server and then four will be uh sending and receiving it for the client okay so this is the same as step six of the server and then five maps on to step seven again so that's the disconnection once uh we've finished with the application so as there is shared code here once we set up the code for the server we can then reuse that for the client as well so let's turn our attention to the code now and let's start with step one which is that the server and the client as well must load the dll by invoking the wsa startup function so let's take a look at the wsa startup function that we have to call first of all so here we see that the function takes two parameters it takes the version that we want to use of the windsock so there may be multiple versions i think there are two and i think 2.2 is the most recent version so we have to format this in a word data type again very low level generic windows data type there usually the types in uppercase are windows types by the way as you're probably seeing so wsa remember stands for windsock api and we also see those uh different data formats throughout the slides coming up okay so back to the version requested yes we have to put that into a word type and we're going to see how that works in a moment and we just have to specify what version that we want to use of winsock so that we load the correct dll corresponding to that version i say i think it's going to be a 2.2 that's the latest version so we'd have to format that and then pass that as a word type for the first parameter of wsa startup and then this second type here is this rather long-winded lpwsa data type and that corresponds to a data structure now we're going to want to pass a pointer to this data structure so that the wsa startup can populate it and we'll see in the next slide that this is just the data structure full of different configuration options different settings that the wsa startup function is going to configure this for us rather conveniently and then once it's finished its task this wsa startup function will return zero if it was successful which is odd because usually it's their way around isn't it usually uh zero corresponds with false or empty meaning that the task wasn't fulfilled successfully but here it's the other round it's zero if it was successful and then anything other than zero which may correspond with an error number which could then be used to be printed out to screen if it was unsuccessful and looking ahead actually i think we do store that in a variable corresponding with a wsa error number so that's what we're going to do there we're going to use that to then check to see whether this wsa startup correctly loaded the dll the winsoc dll or whether we need to put out an error message to the screen to say that there's a problem all right so when we put this all together we'll have a look at that now let's move on and have a look at this lpwsa data structure that is going to be populated by wsa startup so here it's built as a structure here you see the wsa data structure and notice there that there's lots of different attributes referring to versions descriptions statuses different sockets there other types of descriptions and char pointers so thankfully we don't have to worry about specifying all this wsa startup's going to do it for us we just have to pass a pointer to this structure and if successful it will populate all of these different attributes with the corresponding version numbers all right so that's useful let's now put this together and have a look at a full example so here we go here's the first block of code that we're going to need to use in order to load our dll so notice the line in bold here where we call wsa startup now at the first parameter we've created a word variable in the line above and in order to format the version 2.2 into a word type we're going to make use of the low level function make word which will put this together into the specified format so that we can then pass that variable to wsa startup which is w version requested so that's going to do that there and then in the second parameter we're going to pass the reference of our wsa data structure now notice here that we created a variable of that data structure in the first line wsa data of wsa data type so we pass the address of that to wsa startup they're the two parameters and if it's successful it will format that for us as we just said um and if successful it returns zero which notice there we store in wsa e r r short for error and as we said before that's probably going to pass back an error number if the winsock wasn't found and if it was found and loaded okay then it passes back zero so got to apply reverse thinking here to what we usually do we usually check against zero um meaning that it's false or empty but here at several rounds at zero if it was fulfilled and it was found but anything other than zero was not found and notice below we've got some conditional statements here to say that well if anything other than zero was returned to wsa uh err error number that's just an integer by the way if anything other than zero was returned then we didn't find winsock then therefore we've got to put something out to screen to say that but then other than that if wsa startup returned zero then we can say that the windsock was found and then we're also making use of the system status attributes of wsa data to print the appropriate status to screen okay so that may come in useful there and no doubt we'll make use of that further on as we print more updates to screen regarding winsock and the socket connection so that's a useful part of wsa data there even though we don't actually specify the values for these attributes themselves they're useful for printing out the screen all right so that should be all we need for step one to load this dll let's now move on and have a look at step two and to remind you step two is where we create the socket specifying the protocol to be used so this is where we refer to the choice of either using udp or tcp now as we said we're going to go on to explore the differences between them in part two but for now we'll just stick with specifying tcp so let's look at the socket function and the socket function here takes three parameters and you notice that they're actually all integer types so they're more high level than what we've been dealing with so far and in order to specify whether we want to choose udp or tcp we can't pass these inner strings we actually have to use particular constants here to refer to a particular integer value for either tcp or udp okay because they're integer types so the first parameter is referring to the address family okay and so this is a bit more high level uh we just have to pass in af underscore inet there to refer to the fact that we are going to select between either tcp or udp so that's the value that we want to pass in for the first parameter and moving on to the second parameter we specialize within that family type specification because we then choose either sock underscore stream for tcp or sock underscore datagram dgram for udp so i think in these practicals we're going to be using tcp so we're passing the constant sock underscore stream to select tcp and then finally for the third parameter referring to the protocol again we're just going to pass in a constant there for tcp and that works out to be iproto underscore tcp and then the socket function itself takes that information and creates the socket that's bound to that specific communication protocol so whether that's tcp or udp and there's further binding to take place in the next step as well when we talk about binding vip and port number to the socket but that's a a separate step so we'll come on to that but anyway the socket function will return either zero if that binding of the tcp or udp information was successful or not and it was able to create the sockets it turns 0 like a wsa startup but anything other than 0 is going to be a socket error all right and we've actually got a constant for that as well which is all enough a case with a underscore in between and that's going to be returned if there were any problems with binding this information to the socket or creating the socket and we're going to return that so what happens then is as we've already initialized the dll then we're best to deregister our application from using it so that other applications can make use of it and the resources are not stretched too thin so good housekeeping would be to clean up and free up the resources so we can then invoke the wsa cleanup function which will do just that it will free up the dll so that other applications can make use of it so this is a function that we can invoke should the socket function return something other than zero and if we go on to the next slide now we'll see these pieces put together in a full example so here's the second block of code that we're going to need to write and if you have a look at the line in bold again we've got our socket function being invoked and that's going to require the free parameters referring to the tcp constants the first one we specify that we want to choose either tcp or udp so that's afinet just refers to the family of protocols of which tcp and udp are part of and then we get a bit more specific because in the second parameter we pass a sock stream referring to tcp and then again in the third parameter iproto tcp okay so if successful that will return a socket in the form of the type socket and then we can just store that in a local variable so notice we've created a variable called server socket of the socket type in the line above the first line here and then we just got some error checking like we had last time in the first step so if server socket is invalid anything other than zero basically uh meaning that it wasn't uh successfully uh completed then we can output the error message here we can actually make use of wsa get last error and that's a particular function which keeps track of what's happening with a socket and will give us some specific information referring to what that problem was that prevented the creation of the sockets and then as we've just said we then want to free up the resources so we want to unload the dll and say wsa cleanup afterwards if there's a problem so that our applications are not competing with us as we're not making use of this resource we might as well let others make use of it and then if we return zero meaning that we have created the socket then else we're okay all right so that's the second step and just before we move on to the third step let's just briefly say that as we are creating the sockets we also want to then close the socket after we've finished with it so at the end of the full seven steps after we've finished the application like we unloaded the dll if we had a problem we invite wsa cleanup to unload the dll we also want to clean up the resources allocated with the socket so therefore there's a particular function for that which is just called close sockets and then takes the parameter there which refers to the variable that we created to hold the server socket so that's step two then creating the socket so first step just to recap was loading the dll through wsa startup second step was creating the socket through the socket function and now the third step we want to bind the ip address and the port number to the socket and to do this we can make use of the bind function which takes three parameters the first is the variable of the socket type so this is what we just created using the socket function in step two so we can pass that unbound socket to the bind function as the first parameter then the second parameter is going to be the address of a uh variable of a structure and this is the sock addr structure short for the sock address and this is going to be a structure that contains attributes for the ip address and the port number so we'll take a look at that in the following slide but anyway we just passed the address of a variable of the structure to this parameter a little bit like the wsa data structure which we saw in the first step uh difference there was that the function actually populated that for us uh here we're going to fill in some of the details ourselves and then pass it uh past the variable of that structure to this function so it can bind that data to the socket but we'll take a look at that in the next slide but now the third parameter here is just the length of bytes of the structure so we just work out the size of this structure and just pass it as an integer and there's a particular function we can use to work that out for us we don't have to calculate it manually we can use the size of command to work that out all right and then the buying function will bind the data that we passed to it the ip and the port number to the socket and as always it returns a confirmation if it's worked or not and as always it will return 0 if it has been successful but if it wasn't able to bind then it will return something other than 0 it will be a constant which is socket error and then we can unload the dll and also close the sockets as the bind was unsuccessful so let's move on now and have a look at the sock address in structure that we spoke about in the previous slide and as we said this is going to hold some attributes referring to the address family that's the first one and as we know this has to be af underscore inet to refer to the family that contains tcp and udp and we're going to go with tcp but still we have to state that it's of the af underscore inet family as the first attribute and then we have the port number uh we're gonna pass in and then next we have the ip address of the machine and we've also got a fourth parameter here which refers to the size of the structure now we're going to have to adapt our structure to an older type which is the sock a ddr structure now this is slightly different from the sock adr in structure that's a newer structure but we have to adapt our structure to this one and so we've got a bit of padding here just to make our size of our structure adapt to the size of the older structure and also later we're going to make use of a h tons function to convert our port number which uh just in case that's in the host byte order to do a byte placement whether you place the bigger numbers of the byte first uh referred to as big endian or whether you place them at the end referred to as little endian uh there's some variation between cpus as to what order they store the bytes in but anyway the htones function makes sure that anything that's in little endian format is converted into network byte order format which is big endian okay so we'll see that in the next slide and uh just on the previous point mentioning about uh h tons uh we have to pass the port number uh to that function and then that returns it and uh stores it in the sin port attributes of the sock adr in structure which you'll see the variable of that structure is defined as the first line here but what's missing in this code is the assignment of the port number to the port variable okay this is going to be in the practicals you'll see this is just going to be a standard integer variable and we're going to sign the value of 55555 to that and that value stored in the variable port is going to be passed to the h tom's function here all right so you'll get that in the practical it's just not here on this slide but anyway let's focus on the bind function and here it's in the center of the code and it's actually embedded within an if statement here so we're calling bind and we're passing the server socket which we defined and populated from step two as the first parameter and then next as the second parameter we pass in the address of the service variable now that's the variable of the sock addr in structure which you'll see up above we've also assigned values for the attributes of that the af family which is the address family here we're saying that's of inet which is referring to tcp and udp and then we've also defined the loopback address as the ip there 127.0.0.1 and also then converting the port which as we said that was 55555 putting that into the correct might placement order and then putting that in the s i in port attribute of service so basically bundled up all this information in the service variable and then what we're doing is we are casting that to an older sock addr type just for compatibility and consistency there and then in the third parameter of the bind function we are just going to work out the size of the service variable of the sock addr in structure and pass that as the number of bytes alright so all of that if it manages to bind the ip and the port to the socket which we created previously uh then it's going to be okay it's going to go down to the else of this if statement bind was okay returns zero then all is okay but if it returns a value that corresponds with the socket error constant then obviously we've failed to bind the ip and port number to the socket so therefore we're going to get to the last error again we're going to make use of that wsa get last error function which uh handily keeps track of what the problem is and then put a specific message to the screen and then we'll also do a bit housekeeping we'll close the sockets as we're not going to make use of it and also clean up the resources we'll release the dll as well so that's step three now let's move on to look at step four and step four is where we use that newly bound socket to listen out for clients attempting to connect to that socket on the server so let's have a look at the listen function and this is a slightly simpler function as it takes two parameters the first is the socket to listen out on so this is going to be the socket which has just recently been bound it was uh established and created in step two and then bound to the ip and port number in step three and then we pass it to the listen function in step four so it can listen out on that bound socket so that's the first parameter and then the second parameter is an integer corresponding to the maximum number of connections that we want to allow on this socket so we could place a limit to how many clients could choose to connect to this socket at one time so this isn't going to be a major problem in our practical we'll just put one there because we're only going to have one client at a time but in larger scale applications where we might want to specify a limit say we only want to have 30 clients at one time and therefore all the others have to wait until another client is disconnected so that this one can connect then this is where we can specify that uh in accordance with the capacity of the system okay so for us for our example we'll just put one there all right and then as always the listen function will return zero if it was successful and then a value corresponding with socket error if it was unsuccessful okay so let's have a look at the code fragment now and as you see it's a simpler step here for step four we've just placed the call to the listen function within an conditional statement the if statement here and so we're just going to pass the newly established and bound server sockets which we bound in the step three the previous step as the first parameter to listen and then one referring to uh maximum number of connections so that's just going to be for one client okay so pass that to listen and if that was successful then we just output a message to say that listening is good we are able to wait for connections however if it returns value that corresponds with socket error then we just output that there was an error and as always call the wsa get last error function and print out a specific message in accordance with that all right so that's step four and this listening process is actually a two-part process so step five although it's billed as a separate step is actually a continuation of step four and that's the accept functionality and the accept function will actually pause the execution of the server at this point and what it will do it will wait until the client has established a connection with the socket that's currently being used to listen out on and then once that has been established we then accept this uh connection and then move on with the execution of the the server code okay so this accept will actually block the progress of the server until the client has connected with it it's just going to be in this state of listening okay so it's not actually the listening function that pauses the execution it's the accept function here in step five which will uh put the server on pause all right and this accept function will take three parameters it takes the socket which is being used to listen out on okay so that's the socket which we created way back in the second step and then in step three we bound the ip and the port number to that socket and then in step four we used that socket to listen out on okay so it's going to be the same socket um there in the first parameter and then the second parameter here is of type sock addr so hopefully you remember this is what we used in step 3 to hold the ip address and the port number of the machine so we can optionally collect information about the client here perhaps this might be useful for specifying certain client address information if we want to connect to that client only if we know it um in our examples we're just going to put null here we're not particularly interested in collecting this information or mandating that we only connect to a client which has this information so we're just going to put null for this and then same again as with step 3 the length of this structure so as this isn't built as a class and has no attribute referring to the size of it it's not worked out dynamically we need to just specify the expected length of this structure that we are going to be uh receiving so again we're not too interested in that so we're just going to put null there and so really the the important point here is that we uh pass the sockets that we want to listen out on and then this accept function will actually return another socket if you remember back to the visualization we actually created a duplicate of the socket so that we can maintain the first socket for listening out on but then create a dedicated socket for communicating with the client so what we're going to do is we're going to set up another socket variable to store what's being returned by this accept function all right so it's not going to turn 0 this time it will actually return a value of type sockets alright so let's go and have a look at this in an example and here we go we see in the fifth step here the block of code corresponding to the fifth step that first of all we create another socket we've called it accept socket this time and that's going to be the storage location for the value returned by except okay and then we've got the call to the accept function which will pause the execution of the server remember until the client connects to it and then we accept that connection and importantly we need to pass the original socket that was created bound and then is being used to listen out on and will remain being used to listen out on by the way because we keep that separate to the accepted sockets which is the connection between the client and the server to continue there and here we haven't got any positive outputs maybe we could just add something in here to say that we've successfully set up the connection maybe that's going to be part of the chat application functionality which we go on to look at in part two where we send data back and forth between the client and the server but what we have got here is just a message to say well if the socket wasn't returned if a newly created socket wasn't returned by the accept function and instead we have a value corresponding with invalid socket then we just want to output some information to say well there's a problem here called wsa get last error as always to get the specific information and then clean up the resources all right so this should be the code base we require to get the server set up and now let's go on and have a look at the client and you'll see that the client shares the initial steps with the server first of all has to initialize the dll and integrate that with the project and then second step is the same as well has to create a socket at the client end but then the third step is different to the server third step of the server would be to bind the socket to the ip address and the port number of the server but this happens automatically with the client and this will happen when we pass the socket that's been created at the client end to the connect function which is here in step three and also as it's the client we don't have to listen out as that's a task that's specific to the server so the step three and four of the server won't be the same as step three and four of the clients instead the client just connects to the server once it's been set up and is listening out on that socket ready to accept the client connection and then it's able to send and receive okay so let's have a look at the connect function of the client and the connect function of the client has to pass the socket the client socket this is not the server socket we don't have access to that it's on another application but we create the client socket at the client's end so we then pass that socket as the first parameter to the connect function and remember the binding is going to happen automatically so this will be bound to the client's ip address and the port number that's not going to be passed in as the next two parameters which are the sock address structure and the length of that structure so these are the same these are the same format the same structures as what the server went through for setting up and binding the ip address contained within that structure to the socket but here what we're going to do is we're going to specify the server's ip address and port number and assign those to the attributes of the structure which we then pass to the connect function as the second parameter and also the length of the structure as well so this will be the byte size of that uh structure we can use size of again all right so remember difference between the server which is done manually and the client binds the ip address and the port number of the client automatically all right it's at the client end that we specify the server details that we want to connect to so those will be the second two parameters there we'll see that in a moment when we look at the next slide all right and finally on this slide the connection will go ahead for 75 seconds by default waiting for the server to respond so it gives a good amount of time over a minute for the connection to be established but if this wasn't successful then a socket error will be returned and if it is successful the connect function returns zero so this is going back to the format that we've used previously okay so let's look at the code now and uh let's assume that we've been through steps one or two where we've specified the code to initialize the dll the client end and also create the socket the client socket which is referred to here notice that we have created a variable of the sock adddr in structure which is client service and now we've specified the attributes for the server so we've got the loopback address here for the ip and also passing the port of the server which remember that's 55 555 as the port number that's an integer which we're going to uh specify here at the client end and then pass that to the h tons function remember that just puts it into the appropriate byte order for the network to understand and then this is all wrapped up in the client service variable of which we cast to an older sock address structure in order for it to be compatible and then we work out the size of this structure as well pass it to the size of function and that gives us the size and bytes so that's the second and third parameters there and remember the first parameter is going to be the client socket which is bound automatically to the ip address and port number of the client at the client machine all right so pass these details to the connect function and then that will join up with the accept function at the server end so remember the accept function at the server end is going to wait for this function to be called and for the profit details to line up and then when that happens if that works out okay we'll get confirmations at both ends the execution will continue at the server end and the execution here will continue at this end as well so here we'll get the connection okay if that goes through if zero is returned uh we get that it's uh starting to connect and can receive and send data but if we get a socket error anything other than zero being returned at this end client end then we'll do the usual cleanup duties and also output an appropriate error message here as well okay so this should be all we need to get started with setting up our server and client applications to at least connect to each other so what we'll do is we'll pause here and we'll start to code this up and then in part two we'll pick up where this leaves off and have a look at using tcp and udp to send data back and forth from a connected client and server okay so let's transition now and have a go at setting up the client and the server so that they can connect to each other great okay so let's get set up with the exercises for this week and the exercise is to create a server application and also create a client application and get the two to connect to each other on the same machine so i've prepared a project for the server and also one for the clients all right so you need to create two projects here uh two different separate solution files all right so you have to run both at the same time okay but we'll come on to the client a little bit later and i say the the purpose this week is to get them so that they connect to each other and then in the next week's lecture we'll take it further and get them to chat to each other get them to send messages back and forth building on the connection that we establish this week okay and to put the groundwork in place we're going to need to include the library which contains the dll we've got the first part of the document that walks us through that but also we're going to have to make use of some header files and in the later versions of visual studio these may not be included by default so i'll put them up on their blackboard for you but what you're going to have to do is download this stdafx file and also target there as well and you're going to need to include those in the server repository as well as the client repository as well you need to include those within the uh the folder that uh with the cpp for the the main function uh make sure you include those in there and then drag and drop them into the header file folder of visual studio okay because we're going to make use of some of the types that are included in there all right so that's uh the first step and then let's come on to setting up the dependency with the library now we're given the step here and we're going to go to the project menu and we're going to go to properties and then we're going to want to make our way to the linker menu page and then let's go to input and if we scroll down here you'll see there that it's in the additional dependencies it should be the top option it's in there click on or drop down go to edit and it's there that you're going to want to include the link to the winsock library which contains the dll all right so you're going to want to type in here in lowercase ws2 underscore 32.lib alright so that we can make use of winsock and press ok on that tab there and then press apply and ok here so that we should be set up ready to make use of the dll included there so let's do that now let's move on to the first step and rather kindly we've been given the code for the first step so let's just copy this in here as i've got a little bit of formatting in place i'm just going to do it in little steps so let's replace this here oh i didn't include using new spaces let's do that yeah and uh then the code here corresponds to the first step i won't include return zero because that will come right to the end of my main but i'm going to pop that code within here just underneath my header there and i'll tell you what before we go any further let's just check that this runs okay we've got a lot of dependencies so we need to make sure that everything's in place i'm just going to compile it to check yeah so far so good we've found the dll and it's running so that's good hopefully we'll be able to keep that going so let's uh now that we're assured let's go on to the second step which is to set up the sockets all right so scroll down should be able to find the socket creation code which is here call in the socket function so i'm just going to copy and paste this code underneath my step 2 header there we go called the socket function pass the constants referring to tcp so again i'm just going to check each step as we go just to make sure that we're all running yep socket function calls okay that's good all right let's move on to the third step where we attempt to bind the ip and the port number to the socket and should be given the code here so let's copy this in let's pop that in here the bind and let's just check we're running here yeah binds okay that's good news all right so we've bound the ip and the port number of the machine to the socket so that means we're ready now to listen so let's now go on to the fourth step where we want to listen on that socket so this is a slightly easier block of code let's pop that in there uh we've set it up to listen for one client oh i didn't copy all of it sorry let's uh do that again let's uh copy all that in there we go let's try again yeah all good so listening is okay and uh just waiting for connections all right so let's put in the final step here before we transition to the client and this is the accept part so we've set it up so far to listen out on the socket it's going to wait for the client's connect function to connect to these details the ip and the port number and then when that happens we then want to accept it so the accept remember that's going to pause the execution until the connect statement goes through so it's the accept function which pauses the code and it's going to wait for the connection to happens so let's just check that we are going to create and accept sockets maybe we did that up above oh yeah there we go we got both there so we've got a server socket which will maintain the listening and then we've got the accept socket which we want to then um accept once we get confirmation from the client so let's just check this accept is ready to go and then we'll look at the clients yeah and notice that it's uh waiting it's pausing there it's uh waiting for the connection so looking good all right so that should be the server code base uh let's now transition and set up the free steps for the client so that we can get these two running together all right so i've prepared a client project so just create another solution file for the client and let's pop this here for now and remember you're going to want to have the header files in the client repository and also we're going to need to include the link to the library as well so enough to do the same thing here of going to properties and then input and then in the dependencies menu option i want to include the reference of ws2 winsock2 underscore 32 dot lip all right press ok and then apply all right so don't forget to do that so you need to do it for both of them as you will need to for sdd afx and target version header file make sure you create a copy of that and then uh let's see now we should be given the code for the clients now most of it will be the same i think really the only difference here is that we're creating a client socket variable rather than the server socket variable let's just check that we have everything here all right i'm going to need to also include the header files as well so let's go back up here and include all these i need to make use of them and again we'll do a check let's just make sure that we're running step by step make sure that we can find the dll first of all yep looking good so far that's good so that's the dll included let's now set up the client socket now that's for step two of the client so let's go back down to that's the server socket so let's keep going down client code so create a socket for the client this looks to be it let's copy this in and let's run this check again that we are setting up the client sockets yeah all good here and remember unlike the server it's going to bind automatically in the connect statement which is the uh third part of this so we don't need to explicitly call the bind statement here uh we can do that through connect so here we go here's the code for the connection creating the uh well calling the connect function so let's just check we've got everything here yeah we're going to attempt to connect via the client sockets at the specified and look out for the specified ip address and port number which should match the server it's on the same machine as well so it should be using the loopback address let's just check that this will attempt to establish the connection yes so it's waiting so it couldn't connect at the moment because we haven't got the server in play so let's now try and run the two together all right so if i move this client project over here and have my server on this side let's now run the server and the client see if we can get the two connected hopefully the server is going to load first yes it does it should wait out now for the clients hey so that's uh just reposition them here that's good so it happened a bit fast sorry that you might not have seen that but the server did wait for the client to connect and then the client connect worked and then it accepted the connection at the server end and we've just exited the two applications here because we've not got the chat functionality in place but we're going to do that in the next lecture and then take it further all right so have a go at this see if you can get the client and the server set up get them to establish a connection and then we'll take it further next week so see how you get on with that 